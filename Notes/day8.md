Excellent! Let's move to **Day 8: Database Migrations with Flyway**.

## Day 8: Version-Controlled Database Schema Management

### What We'll Accomplish Today
By the end of today, you'll have:
1. Set up Flyway for database migrations
2. Created version-controlled SQL migration files
3. Managed schema evolution across different environments
4. Learned how to handle data migrations
5. Understood rollback strategies and best practices

---

### Step 1: Understanding the Problem with Current Approach

Currently, we're using:
- `spring.jpa.hibernate.ddl-auto=create-drop`
- Hibernate auto-generates schema on startup
- **No control** over schema changes
- **No version history** of database changes
- **Cannot track** what changed and when
- **Dangerous in production**

### Step 2: Add Flyway Dependency

Add Flyway dependency to your `pom.xml`:

```xml
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
```

### Step 3: Configure Flyway

Update your configuration files to use Flyway instead of Hibernate DDL auto-generation:

**`src/main/resources/application.yml`** (Common configuration)
```yaml
spring:
  jpa:
    hibernate:
      ddl-auto: validate  # Flyway will handle DDL, Hibernate only validates
    show-sql: true
    properties:
      hibernate:
        format_sql: true

# Flyway Configuration
flyway:
  enabled: true
  locations: classpath:db/migration
  baseline-on-migrate: true
  validate-on-migrate: true
```

**`src/main/resources/application-dev.yml`**
```yaml
spring:
  datasource:
    url: jdbc:h2:mem:devdb
    username: sa
    password: 
    driver-class-name: org.h2.Driver
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect

flyway:
  clean-disabled: false  # Allow clean for dev (be careful!)
```

**`src/main/resources/application-prod.yml`**
```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/bookdb
    username: produser
    password: prodpass
    driver-class-name: org.postgresql.Driver
  jpa:
    database-platform: org.hibernate.dialect.PostgreSQLDialect

flyway:
  clean-disabled: true  # Never allow clean in production!
```

### Step 4: Create Migration Directory Structure

Create the directory structure for migrations:
```
src/main/resources/db/migration/
```

### Step 5: Create Initial Migration

Let's create our first migration that sets up the initial schema:

**`src/main/resources/db/migration/V1__Create_books_table.sql`**
```sql
-- Create books table
CREATE TABLE books (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    author VARCHAR(255) NOT NULL,
    publication_year INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for better performance
CREATE INDEX idx_books_title ON books(title);
CREATE INDEX idx_books_author ON books(author);
CREATE INDEX idx_books_publication_year ON books(publication_year);

-- Insert initial data
INSERT INTO books (title, author, publication_year) VALUES
('The Great Gatsby', 'F. Scott Fitzgerald', 1925),
('To Kill a Mockingbird', 'Harper Lee', 1960),
('1984', 'George Orwell', 1949),
('The Hobbit', 'J.R.R. Tolkien', 1937);
```

### Step 6: Test the Initial Migration

Start your application with the dev profile:
```bash
./mvnw spring-boot:run -Dspring-boot.run.arguments=--spring.profiles.active=dev
```

You should see Flyway output in the logs:
```
INFO  Flyway: Database: jdbc:h2:mem:devdb (H2 2.1)
INFO  Flyway: Successfully validated 1 migration (execution time 00:00.010s)
INFO  Flyway: Creating Schema History table "PUBLIC"."flyway_schema_history"
INFO  Flyway: Current version of schema "PUBLIC": << Empty Schema >>
INFO  Flyway: Migrating schema "PUBLIC" to version "1 - Create books table"
INFO  Flyway: Successfully applied 1 migration to schema "PUBLIC", now at version v1
```

### Step 7: Explore the Flyway Schema History

Connect to H2 console (`http://localhost:8080/h2-console`) and check:
- The `books` table with our initial data
- The `flyway_schema_history` table that tracks migrations

Run this query to see migration history:
```sql
SELECT * FROM flyway_schema_history;
```

### Step 8: Add a New Column Migration

Let's add a new feature - book genres. Create a new migration:

**`src/main/resources/db/migration/V2__Add_genre_column.sql`**
```sql
-- Add genre column to books table
ALTER TABLE books ADD COLUMN genre VARCHAR(100);

-- Update existing books with genres
UPDATE books SET genre = 'Classic' WHERE title = 'The Great Gatsby';
UPDATE books SET genre = 'Fiction' WHERE title = 'To Kill a Mockingbird';
UPDATE books SET genre = 'Dystopian' WHERE title = '1984';
UPDATE books SET genre = 'Fantasy' WHERE title = 'The Hobbit';

-- Add index for genre
CREATE INDEX idx_books_genre ON books(genre);
```

### Step 9: Update Book Entity

Update the Book entity to include the new genre field:

**`src/main/java/com/sujan/springbootmastery/model/Book.java`**
```java
@Entity
@Table(name = "books")
public class Book {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank(message = "Title is required")
    @Size(min = 1, max = 255, message = "Title must be between 1 and 255 characters")
    private String title;
    
    @NotBlank(message = "Author is required")
    @Size(min = 1, max = 255, message = "Author must be between 1 and 255 characters")
    private String author;
    
    @Min(value = 1000, message = "Publication year must be after 1000")
    @Max(value = 2100, message = "Publication year seems too far in the future")
    @Column(name = "publication_year")
    private Integer publicationYear;
    
    @Size(max = 100, message = "Genre must not exceed 100 characters")
    private String genre;
    
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // Constructors
    public Book() {}
    
    public Book(String title, String author, Integer publicationYear) {
        this.title = title;
        this.author = author;
        this.publicationYear = publicationYear;
    }
    
    public Book(String title, String author, Integer publicationYear, String genre) {
        this.title = title;
        this.author = author;
        this.publicationYear = publicationYear;
        this.genre = genre;
    }
    
    // Pre-persist and pre-update methods for timestamps
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
    
    // Getters and Setters (add new ones)
    public String getGenre() { return genre; }
    public void setGenre(String genre) { this.genre = genre; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    
    // ... rest of existing getters/setters
}
```

### Step 10: Create a Complex Migration with Constraints

Let's add a new table for book reviews and establish relationships:

**`src/main/resources/db/migration/V3__Create_reviews_table.sql`**
```sql
-- Create reviews table
CREATE TABLE reviews (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    book_id BIGINT NOT NULL,
    reviewer_name VARCHAR(255) NOT NULL,
    rating INT NOT NULL CHECK (rating >= 1 AND rating <= 5),
    comment TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Foreign key constraint
    CONSTRAINT fk_review_book FOREIGN KEY (book_id) 
        REFERENCES books(id) ON DELETE CASCADE
);

-- Create indexes for reviews
CREATE INDEX idx_reviews_book_id ON reviews(book_id);
CREATE INDEX idx_reviews_rating ON reviews(rating);

-- Insert sample reviews
INSERT INTO reviews (book_id, reviewer_name, rating, comment) VALUES
(1, 'sujan Doe', 5, 'A masterpiece of American literature'),
(1, 'Jane Smith', 4, 'Beautiful writing, complex characters'),
(2, 'Bob sujanson', 5, 'Timeless classic that everyone should read'),
(3, 'Alice Brown', 4, 'Chilling and prophetic'),
(4, 'Charlie Wilson', 5, 'The beginning of an epic adventure');
```

### Step 11: Create Review Entity

Create a new entity for reviews:

**`src/main/java/com/sujan/springbootmastery/model/Review.java`**
```java
package com.sujan.springbootmastery.model;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import jakarta.validation.constraints.*;

@Entity
@Table(name = "reviews")
public class Review {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "book_id", nullable = false)
    @JsonBackReference
    private Book book;
    
    @NotBlank(message = "Reviewer name is required")
    @Size(max = 255, message = "Reviewer name must not exceed 255 characters")
    @Column(name = "reviewer_name", nullable = false)
    private String reviewerName;
    
    @NotNull(message = "Rating is required")
    @Min(value = 1, message = "Rating must be at least 1")
    @Max(value = 5, message = "Rating must be at most 5")
    private Integer rating;
    
    @Column(columnDefinition = "TEXT")
    private String comment;
    
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;
    
    // Constructors
    public Review() {}
    
    public Review(Book book, String reviewerName, Integer rating, String comment) {
        this.book = book;
        this.reviewerName = reviewerName;
        this.rating = rating;
        this.comment = comment;
    }
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public Book getBook() { return book; }
    public void setBook(Book book) { this.book = book; }
    
    public String getReviewerName() { return reviewerName; }
    public void setReviewerName(String reviewerName) { this.reviewerName = reviewerName; }
    
    public Integer getRating() { return rating; }
    public void setRating(Integer rating) { this.rating = rating; }
    
    public String getComment() { return comment; }
    public void setComment(String comment) { this.comment = comment; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}
```

### Step 12: Update Book Entity with Reviews Relationship

Add the relationship to Book entity:

**`src/main/java/com/sujan/springbootmastery/model/Book.java`**
```java
// Add this import
import com.fasterxml.jackson.annotation.JsonManagedReference;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "books")
public class Book {
    
    // ... existing fields ...
    
    @OneToMany(mappedBy = "book", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonManagedReference
    private List<Review> reviews = new ArrayList<>();
    
    // Add getter and setter for reviews
    public List<Review> getReviews() { return reviews; }
    public void setReviews(List<Review> reviews) { this.reviews = reviews; }
    
    // Helper method to add review
    public void addReview(Review review) {
        reviews.add(review);
        review.setBook(this);
    }
    
    // Helper method to remove review
    public void removeReview(Review review) {
        reviews.remove(review);
        review.setBook(null);
    }
}
```

### Step 13: Create Repository for Reviews

**`src/main/java/com/sujan/springbootmastery/repository/ReviewRepository.java`**
```java
package com.sujan.springbootmastery.repository;

import com.sujan.springbootmastery.model.Review;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ReviewRepository extends JpaRepository<Review, Long> {
    
    List<Review> findByBookId(Long bookId);
    List<Review> findByRatingGreaterThanEqual(Integer minRating);
    List<Review> findByBookIdOrderByCreatedAtDesc(Long bookId);
}
```

### Step 14: Create Service and Controller for Reviews

**`src/main/java/com/sujan/springbootmastery/service/ReviewService.java`**
```java
package com.sujan.springbootmastery.service;

import com.sujan.springbootmastery.model.Review;
import java.util.List;

public interface ReviewService {
    
    List<Review> getReviewsByBookId(Long bookId);
    Review createReview(Long bookId, Review review);
    void deleteReview(Long reviewId);
    List<Review> getHighRatedReviews(Integer minRating);
    Double getAverageRatingForBook(Long bookId);
}
```

**`src/main/java/com/sujan/springbootmastery/service/ReviewServiceImpl.java`**
```java
package com.sujan.springbootmastery.service;

import com.sujan.springbootmastery.exception.ResourceNotFoundException;
import com.sujan.springbootmastery.model.Book;
import com.sujan.springbootmastery.model.Review;
import com.sujan.springbootmastery.repository.BookRepository;
import com.sujan.springbootmastery.repository.ReviewRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class ReviewServiceImpl implements ReviewService {
    
    private final ReviewRepository reviewRepository;
    private final BookRepository bookRepository;
    
    @Autowired
    public ReviewServiceImpl(ReviewRepository reviewRepository, BookRepository bookRepository) {
        this.reviewRepository = reviewRepository;
        this.bookRepository = bookRepository;
    }
    
    @Override
    public List<Review> getReviewsByBookId(Long bookId) {
        return reviewRepository.findByBookIdOrderByCreatedAtDesc(bookId);
    }
    
    @Override
    public Review createReview(Long bookId, Review review) {
        Book book = bookRepository.findById(bookId)
                .orElseThrow(() -> new ResourceNotFoundException("Book", "id", bookId.toString()));
        
        review.setBook(book);
        return reviewRepository.save(review);
    }
    
    @Override
    public void deleteReview(Long reviewId) {
        if (!reviewRepository.existsById(reviewId)) {
            throw new ResourceNotFoundException("Review", "id", reviewId.toString());
        }
        reviewRepository.deleteById(reviewId);
    }
    
    @Override
    public List<Review> getHighRatedReviews(Integer minRating) {
        return reviewRepository.findByRatingGreaterThanEqual(minRating);
    }
    
    @Override
    public Double getAverageRatingForBook(Long bookId) {
        List<Review> reviews = reviewRepository.findByBookId(bookId);
        if (reviews.isEmpty()) {
            return 0.0;
        }
        
        return reviews.stream()
                .mapToInt(Review::getRating)
                .average()
                .orElse(0.0);
    }
}
```

**`src/main/java/com/sujan/springbootmastery/controller/ReviewController.java`**
```java
package com.sujan.springbootmastery.controller;

import com.sujan.springbootmastery.model.Review;
import com.sujan.springbootmastery.service.ReviewService;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/books/{bookId}/reviews")
public class ReviewController {
    
    private static final Logger logger = LoggerFactory.getLogger(ReviewController.class);
    
    private final ReviewService reviewService;
    
    @Autowired
    public ReviewController(ReviewService reviewService) {
        this.reviewService = reviewService;
    }
    
    @GetMapping
    public ResponseEntity<List<Review>> getReviewsByBookId(@PathVariable Long bookId) {
        logger.info("GET /api/books/{}/reviews - Fetching reviews", bookId);
        List<Review> reviews = reviewService.getReviewsByBookId(bookId);
        return ResponseEntity.ok(reviews);
    }
    
    @PostMapping
    public ResponseEntity<Review> createReview(
            @PathVariable Long bookId, 
            @Valid @RequestBody Review review) {
        
        logger.info("POST /api/books/{}/reviews - Creating review", bookId);
        Review createdReview = reviewService.createReview(bookId, review);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdReview);
    }
    
    @DeleteMapping("/{reviewId}")
    public ResponseEntity<String> deleteReview(
            @PathVariable Long bookId, 
            @PathVariable Long reviewId) {
        
        logger.info("DELETE /api/books/{}/reviews/{} - Deleting review", bookId, reviewId);
        reviewService.deleteReview(reviewId);
        return ResponseEntity.ok("Review deleted successfully");
    }
    
    @GetMapping("/stats/average-rating")
    public ResponseEntity<Double> getAverageRating(@PathVariable Long bookId) {
        logger.info("GET /api/books/{}/reviews/stats/average-rating", bookId);
        Double averageRating = reviewService.getAverageRatingForBook(bookId);
        return ResponseEntity.ok(averageRating);
    }
}
```

### Step 15: Test the Migrations and New Features

Start your application and test the new features:

```bash
./mvnw spring-boot:run -Dspring-boot.run.arguments=--spring.profiles.active=dev
```

**Test the new review endpoints:**
```bash
# Get reviews for a book
curl http://localhost:8080/api/books/1/reviews

# Create a new review
curl -X POST http://localhost:8080/api/books/1/reviews \
  -H "Content-Type: application/json" \
  -d '{
    "reviewerName": "Test User",
    "rating": 5,
    "comment": "Amazing book!"
  }'

# Get average rating
curl http://localhost:8080/api/books/1/reviews/stats/average-rating
```

### Step 16: Create a Repeatable Migration

Repeatable migrations run every time their checksum changes. Let's create a view:

**`src/main/resources/db/migration/R__Create_book_stats_view.sql`**
```sql
-- Repeatable migration for book statistics view
CREATE OR REPLACE VIEW book_stats AS
SELECT 
    b.id,
    b.title,
    b.author,
    b.genre,
    b.publication_year,
    COUNT(r.id) as review_count,
    COALESCE(AVG(r.rating), 0) as average_rating,
    b.created_at
FROM books b
LEFT JOIN reviews r ON b.id = r.book_id
GROUP BY b.id, b.title, b.author, b.genre, b.publication_year, b.created_at;
```

### Step 17: Flyway Command Line (Optional)

You can also use Flyway command line to manage migrations:

```bash
# Check migration status
./mvnw flyway:info

# Validate migrations
./mvnw flyway:validate

# Repair migrations (if checksums change)
./mvnw flyway:repair

# Clean database (DEV ONLY!)
./mvnw flyway:clean
```

### Day 8 Challenge

1. **Create a migration** that adds a `publisher` column to the books table
2. **Create a data migration** that backfills publisher information for existing books
3. **Add a new table** for authors with a proper relationship to books

### Solution to Challenge #1

**`src/main/resources/db/migration/V4__Add_publisher_column.sql`**
```sql
-- Add publisher column
ALTER TABLE books ADD COLUMN publisher VARCHAR(255);

-- Backfill existing data
UPDATE books SET publisher = 'Scribner' WHERE title = 'The Great Gatsby';
UPDATE books SET publisher = 'J.B. Lippincott & Co.' WHERE title = 'To Kill a Mockingbird';
UPDATE books SET publisher = 'Secker & Warburg' WHERE title = '1984';
UPDATE books SET publisher = 'George Allen & Unwin' WHERE title = 'The Hobbit';

-- Add index
CREATE INDEX idx_books_publisher ON books(publisher);
```

### Key Takeaways from Day 8

✅ **Database Version Control**: Flyway manages schema changes as versioned files  
✅ **Migration Naming**: `V1__Description.sql` for versioned, `R__Description.sql` for repeatable  
✅ **Safe Deployments**: Migrations are applied safely across environments  
✅ **Data Migrations**: Can include data changes alongside schema changes  
✅ **Rollforward Strategy**: Flyway only moves forward, no automatic rollbacks  
✅ **Production Safety**: `validate` ensures applied migrations haven't changed  

### What's Next?

Tomorrow (Day 9) we'll dive into **Security with Spring Security** - authentication, authorization, and securing our API!

**When you're ready for Day 9, just say "next"!** Practice today's concepts by creating more complex migrations and testing them across different environments.